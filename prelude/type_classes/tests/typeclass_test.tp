(require prelude/test
         prelude/data/maybe
         prelude/type_classes/num
         prelude/type_classes/functor
         prelude/type_classes/monoid
         prelude/type_classes/monad)

;; Num Int
(test "Num Int -> addition"
      (assert (equal? (+ 5 5) 10)))

(test "Num Int -> multiplication"
      (assert (equal? (* 5 5) 25)))

(test "Num Int -> abs"
      (assert (equal? (abs (negate 5)) 5)))

(test "Num Int -> negate"
      (assert (equal? (negate (negate 5)) 5)))

(test "Num Int -> signum positive"
      (assert (equal? (signum 5) 1)))

(test "Num Int -> signum zero"
      (assert (equal? (signum 0) 0)))

(test "Num Int -> signum negative"
      (assert (equal? (signum (negate 5)) (negate 1))))

;; Num Float
(test "Num Float -> addition"
      (assert (equal? (+ 5.5 5.5) 11.0)))

(test "Num Float -> multiplication"
      (assert (equal? (* 5.5 5.5) 30.25)))

(test "Num Float -> abs"
      (assert (equal? (abs (negate 5.5)) 5.5)))

(test "Num Float -> negate"
      (assert (equal? (negate (negate 5.5)) 5.5)))

(test "Num Float -> signum positive"
      (assert (equal? (signum 5.5) 1.0)))

(test "Num Float -> signum zero"
      (assert (equal? (signum 0.0) 0.0)))

(test "Num Float -> signum negative"
      (assert (equal? (signum (negate 5.5)) (negate 1.0))))

;; Monoid List
(test "Monoid List -> append two lists"
      (assert (equal? (mappend '(1 2 3) '(8 9 10)) '(1 2 3 8 9 10))))

(test "Monoid List -> append mempty to a list"
      (assert (equal? (mappend '(1 2 3) mempty) '(1 2 3))))

(test "Monoid List -> append a list to mempty"
      (assert (equal? (mappend mempty '(1 2 3)) '(1 2 3))))

;; Functor List
(test "Functor List -> map square over a list of Ints"
      (let-values
          ([square (lambda (x) (* x x))])
        (assert (equal? (map square '(1 2 3 4 5)) '(1 4 9 16 25)))))

;; Functor Maybe
(test "Functor Maybe -> map square over Just Int"
      (let-values
          ([square (lambda (x) (* x x))])
        (assert (equal? (map square (Just 5)) (Just 25)))))

(test "Functor Maybe -> map square over Nothing"
      (let-values
          ([square (lambda (x) (* x x))])
        (assert (equal? (map square (Nothing)) (Nothing)))))

;; Monad
(test "Monad Maybe -> bind with a return of inferred type (Just)"
      (let-values
          ([result (bind (Just 5) (lambda (x) (return (+ x 5))))])
        (assert (equal? result (Just 10)))))

(test "Monad Maybe -> bind with a return of inferred type (Nothing)"
      (let-values
          ([result (bind (Nothing) (lambda (x) (return (+ x 5))))])
        (assert (equal? result (Nothing)))))
